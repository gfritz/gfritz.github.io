<html>
  <head>
    <meta charSet="utf-8"></meta>
    <title>
      Welcome
    </title>
    <link rel="stylesheet" type="text/css" href="/css/style.css"></link>
    <link rel="alternate" type="application/atom+xml" href="/feed.xml" title="News Feed"></link>
  </head>
  <body>
    <div class="container">
      <header class="masthead">
        <h3 class="masthead-title">
          <a href="/">
            Garth Blog
          </a>
          <small class="masthead-link">
            <a href="/archive.html">
              Archive
            </a>
          </small>
        </h3>
      </header>
      <div id="content">
        <article class="post">
          <h1 class="post-title">
            <a href="/posts/2020-12-05-fsadvent-2020-dependency-injection-using-flexible-types-and-type-inference.html">
              FsAdvent 2020 - Dependency Injection Using Flexible Types and Type Inference
            </a>
          </h1>
          <div class="post-date">
            12/5/2020
          </div>
          <h1>Dependency Injection Using Flexible Types and Type Inference</h1>
<h2>F# Advent 2020</h2>
<p>This is a post for <a href="https://sergeytihon.com/2020/10/22/f-advent-calendar-in-english-2020/">F# Advent 2020</a> facilitated by Sergey Tihon. Visit the link to see many more posts about F#.</p>
<h2>Motivation</h2>
<p>When I read <a href="https://bartoszsypytkowski.com/dealing-with-complex-dependency-injection-in-f/">Bartosz Sypytkowski's article on Dealing with complex dependency injection in F#</a>, I knew I had to try out his method. I think his article shows a promising alternative to the &quot;standard&quot; dependency injection approaches you see in C# while using core F# features. This post is about my experience using what he calls an &quot;environment parameter&quot; for dependency injection. In short, I found the experience refreshing, and I am eager to see how the environment parameter handles changes in my application. First, I should explain why &quot;standard&quot; dependency injection is not enough for me.</p>
<h3>.NET Dependency Injection is Boring and Repetitive</h3>
<p>The dependency injection I see most often in C# (.NET Core / .NET 5) looks and feels mechanical - use interfaces and instantiate the dependencies at startup yourself or register the interfaces in some dependency injection container. Then, you find out at runtime if you, or your dependency container, missed an interface or implementation. This approach looks like the default way to encapsulate and manage dependencies in .NET with fair reasons - it sounds simple, looks unsurprising (at least before runtime), and C# tooling makes it feel natural. It is boring and repetitive.</p>
<p>Can F# make dependency injection less mechanical for the developer? Can the language figure out what dependencies you need based on how they are used?</p>
<p>If you already read Bartosz's article, you should not be surprised that I think the answer is &quot;yes, probably&quot;. The rest of this post will assume you have not read the article, but you really should. If you do read the post, then there will be some questions that sound rhetorical. In this case, try not to roll your eyes too hard. This post is my way of comprehending Bartosz's method.</p>
<h2>What Does F# Offer?</h2>
<p>Advocates for F# like to mention the type system, partial application, and type inference. Partial application is a tempting approach, and it seems like an answer to my questions from the previous section. Broadly speaking, you write a function and type inference figures out the types of the arguments and return value based on usage elsewhere in the codebase.</p>
<h3>Partial Application</h3>
<p>Unfortunately, I do not think this is less mechanical in practice than the &quot;standard&quot; C# approach.</p>
<p>If you create and use a new dependency, you must add another field or constructor argument to services consuming the new dependency. If an existing dependency needs another capability, you will probably add another parameter and update all services that use this dependency. This feels like something the compiler and type inference can handle for us, but how do we make that happen?</p>
<h3>Flexible Types</h3>
<p>Refer to the <a href="https://docs.microsoft.com/en-us/dotnet/fsharp/language-reference/flexible-types">F# Language Reference for Flexible Types</a>.</p>
<p>This type annotation allows us to specify that a &quot;a parameter, variable, or value has a type that is compatible with a specified type&quot;. My understanding is that this annotation combined with two interfaces is what enables F# type inference to . Why two interfaces? One interface is for methods tailored to your application logic, and the other interface is to isolate a particular choice of infrastructure (logging, database, some API). Your &quot;environment parameter&quot; will expose the interfaces tailored to your application core logic.</p>
<h2>An Example</h2>
<p>I made an internal dotnet cli tool to perform some specific tasks against my company's Stash (Bitbucket) REST API. The cli should apply certain repository permissions sourced from a settings file in a central repository. In other words, the tool supports an infrastructure as code workflow for development teams for their source code repository settings. It was a personal project with simple requirements, so I used it to try out the &quot;environment parameter&quot; approach.</p>
<p>The cli needed a few dependencies: logging, an authenticated http client, and an API to perform the necessary Stash REST API operations. Let's finally see some code trimmed down to show just the environment parameter, so no validation or <code>Result</code>.</p>
<h3>Logger Dependency</h3>
<pre><code class="language-fsharp">/// Application will log via these methods.
[&lt;Interface&gt;]
type IAppLogger =
  abstract Debug: string -&gt; unit
  abstract Error: string -&gt; unit

/// env object will use this interface
[&lt;Interface&gt;]
type ILog =
  abstract Logger: IAppLogger

/// #ILog means env can be any type compatible with ILog interface.
/// This is the 'flexible type' annotation and where type inference
/// resolves a compatible interface - it figures out the dependency for us at compile time!
module Log =
  let debug (env: #ILog) fmt =
    Printf.kprintf env.Logger.Debug fmt

  let error (env: #ILog) fmt =
    Printf.kprintf env.Logger.Error fmt

  // Adapt the dependency to IAppLogger.
  // Here I am lazy and log to console, but you can use Microsoft ILogger, NLog, or whatever.
  // if the logger needs configuration, I recommend making any config objects be parameters to `live`.
  let live : IAppLogger =
    { new IAppLogger with
        member _.Debug message = Console.WriteLine (&quot;DEBUG: &quot; + message)
        member _.Error message = Console.WriteLine (&quot;ERROR: &quot; + message) }
</code></pre>
<p>Next, let's see how a <code>findUser</code> function looks that only uses <code>ILog</code>.</p>
<pre><code class="language-fsharp">// val findUser: 
//   env       : ILog   -&gt;
//   searchTerm: string 
//            -&gt; unit
let findUser env = fun searchTerm -&gt;
	Log.debug env &quot;Searching for user with search term: \&quot;%s\&quot;&quot; searchTerm

</code></pre>
<p>This function does not do anything useful, and the function signature is not surprising. This is just the usual type inference you would expect to see. We need to use another dependency to see an interesting difference in the signature.</p>
<h3>Users API Dependency</h3>
<p>Next, let's define the <code>IStashUsers</code> and <code>IStashApi</code>. If the need for the two logging interfaces was clear, then we can say the two Stash interfaces are analogous to <code>IAppLogger</code> and <code>ILog</code> interfaces respectively. The first is what the application logic needs, and the second is what the &quot;flexible types&quot; annotation uses to enable the compiler to infer the correct interface and <strong>implicitly</strong> add the dependency to the environment type definition. At least, that is how I understand it. Hopefully not wrong!</p>
<pre><code class="language-fsharp">// I decided to go perhaps a little too far by isolating the serializer dependency too.
// With System.Text.Json, this may not be remotely useful anymore.
[&lt;Interface&gt;]
type ISerializer =
  abstract Deserialize&lt;'t&gt; : HttpContent -&gt; Async&lt;'t&gt;
  abstract Serialize : 't -&gt; string

module Serializer =
  open Newtonsoft.Json
  open Newtonsoft.Json.Serialization

  let private settings = JsonSerializerSettings()
  settings.ContractResolver &lt;- CamelCasePropertyNamesContractResolver()

  let live =
    { new ISerializer with
        member _.Deserialize&lt;'t&gt; httpContent =
          async {
              let! stringContent = httpContent.ReadAsStringAsync() |&gt; Async.AwaitTask
              let deserialized = JsonConvert.DeserializeObject&lt;'t&gt;(stringContent, settings)
              return deserialized
          }
        member _.Serialize toSerialize =
          JsonConvert.SerializeObject(toSerialize, settings)
    }

[&lt;Interface&gt;]
type IStashUsers =
  abstract GetByUserName: string -&gt; PageResponse&lt;Incoming.UserDto&gt;

[&lt;Interface&gt;]
type IStashApi =
  abstract Users: IStashUsers

module StashUsers =

  let getUserByUserName (env: #IStashApi) searchTerm =
    env.Users.GetByUserName searchTerm

  let live (serializer: ISerializer) stashApiUrl accessToken : IStashUsers =
    { new IStashUsers with
        member _.GetByUserName userName =
          async {
              let! response =
                  FsHttp.DslCE.Builder.httpAsync {
                      GET (sprintf &quot;%s/rest/api/1.0/admin/users?filter=%s&quot; stashApiUrl (Http.encode userName))
                      Authorization (sprintf &quot;Bearer %s&quot; accessToken)
                  }

              return! serializer.Deserialize&lt;PageResponse&lt;Incoming.UserDto&gt;&gt; response.content response
          }
    }

</code></pre>
<h3>Using Two Dependencies Together</h3>
<p>Notice how <code>env</code> changed to require both <code>ILog</code> and <code>IStashApi</code> once <code>findUser</code> uses <code>Log.debug</code> and <code>StashUsers.getUserByUserName</code>. Again, this type inference works because the <code>Log</code> and <code>StashUsers</code> modules use the <code>#ILog</code> and <code>#IStashApi</code> flexible type annotations respectively.</p>
<pre><code class="language-fsharp">
// val findUser: 
//    env       : 'a     (requires :&gt; ILog and :&gt; IStashApi )-&gt;
//    searchTerm: string 
//             -&gt; option&lt;UserDto&gt;
let findUser env = fun searchTerm -&gt;
  Log.debug env &quot;Searching for user with search term: \&quot;%s\&quot;&quot; searchTerm

  // PageResponse&lt;UserDto&gt;
  let x = StashUsers.getUserByUserName env searchTerm

  // option&lt;UserDto&gt;
  let user = x.Values |&gt; Array.tryHead

  Log.debug env &quot;Best match for %s is %s&quot; searchTerm user.Name
  
  user

</code></pre>
<h2>Does Environment Parameter Answer My Questions?</h2>
<p>The questions were:</p>
<ul>
<li>Can F# make dependency injection less mechanical for the developer?</li>
<li>Can the language figure out what dependencies you need based on how they are used?</li>
</ul>
<p>I think the answer is <strong>yes, probably</strong>.</p>
<p>If I take away all uses of the <code>Log</code> module from <code>findUser</code> then <code>env</code> type signature is only <code>IStashApi</code>.</p>
<p>If I create a third module <code>SomeOtherDependency</code> following the same two interface pattern with <code>#ISomeOtherDependency</code> flexible type annotation pattern and use that module in <code>findUser</code>, then <code>env</code> will automatically be inferred to require the third interface. Pretty convenient!</p>
<p>I do not depend on some library or framework. Type inference and flexible type annotations are standard F# language features. If the environment type does not meet the needs of some function in some module, the code will not compile.</p>
<p>You still need to provide proper configurations, connection strings, etc at startup. The compiler does not check that, unless you are willing to add in a type provider. <a href="https://fsprojects.github.io/SQLProvider/">SQLProvider</a> for example checks queries against a real database at compile time. Maybe there is a type provider or similar tool to do that for your configured dependency? That does not sound worth the effort and is beyond the scope of this post.</p>
<h3>Remaining Questions</h3>
<p>So far this post sounds like I am totally sold and have no other concerns. That is not true. I have some unanswered and untested questions.</p>
<ul>
<li>How to handle service lifetime and scoping, if at all?</li>
<li>Can this approach be accomplished in C#?
<ul>
<li>Perhaps by using <a href="https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/generics/constraints-on-type-parameters">type constraints</a>, but I think C# would need type inference. No idea.</li>
</ul>
</li>
<li>Is this easier than &quot;standard&quot; C# Microsoft.Extensions.DependencyInjection?
<ul>
<li>I think so, but my application is still simple compared to other codebases I work with.</li>
</ul>
</li>
</ul>
<h2>Links and Contact</h2>
<p>View the other <a href="https://sergeytihon.com/2020/10/22/f-advent-calendar-in-english-2020/">F# Advent 2020 posts</a>!</p>
<p>I would like to thank Bartosz for his post. I think it showed me a middle ground between partial application and a reader monad that I would not have found by myself.</p>
<p>Links:</p>
<ul>
<li><a href="https://bartoszsypytkowski.com/dealing-with-complex-dependency-injection-in-f/">Dealing with complex dependency injection in F# - Bartosz Sypytkowski, 22-Mar-2020</a></li>
<li><a href="https://docs.microsoft.com/en-us/dotnet/fsharp/language-reference/flexible-types">F# Language Reference: Flexible Types</a></li>
</ul>
<p>Contact:</p>
<p>I do not have a comments section, so please use <a href="https://twitter.com/garthfritz/">@garthfritz on Twitter</a> or <code>@garth</code> on the <a href="https://fsharp.org/guides/slack/">F# Software Foundation Slack (slack access requires free F# Software Foundation membership)</a> to contact me with feedback or clarification.</p>

        </article>
        <article class="post">
          <h1 class="post-title">
            <a href="/posts/2019-12-24-fsadvent-2019-fake-and-build-server.html">
              FsAdvent 2019 - Using FAKE in a Build Server
            </a>
          </h1>
          <div class="post-date">
            12/24/2019
          </div>
          <h1>Using FAKE in a Build Server</h1>
<h2>F# Advent 2019</h2>
<p>This is a post for <a href="https://sergeytihon.com/2019/11/05/f-advent-calendar-in-english-2019/">F# Advent 2019</a> facilitated by Sergey Tihon. Visit the link to see many more posts about F#.</p>
<h2>Integrating with TeamCity</h2>
<p>This article will be TeamCity specific, but there is not much configuration needed to use FAKE.</p>
<p>In short, configure your build agent to run your FAKE <code>*.fsx</code> script, and have your script pull in build agent variables, like nuget feeds, docker feeds, credentials, build counter, via environment variables.</p>
<p>Always try to write your scripts to be <a href="https://fake.build/buildserver.html#General-API-usage">build server agnostic</a>. Even isolating a build server specific dependency behind a function is better than not isolating the dependency at all.</p>
<p>To use FAKE, your build server needs at least one of the following on one or more of its build agents:</p>
<ul>
<li>install .NET SDK 2.1+ on your build agent for dotnet tool support, or</li>
<li>install Docker on your build agent and specify a Dockerfile for your build agent dependencies.</li>
</ul>
<p>Add these lines to your build script to integrate with TeamCity:</p>
<pre><code class="language-fsharp">open Fake.Core
open Fake.BuildServer

BuildServer.install [ TeamCity.Installer ]
</code></pre>
<p>Next, modify your TeamCity configuration:</p>
<ul>
<li>Select Runner Type = Command Line,</li>
<li>Name the step something like &quot;Run FAKE script&quot;, or whatever you like,</li>
<li>Execute step = &quot;If all previous steps finished successfully&quot;,</li>
<li>Run = &quot;Custom Script&quot;,</li>
<li>Custom Scripts = <code>fake build target CIBuild</code>,</li>
<li>Format stderr output as = &quot;error&quot;,</li>
<li>Run step within Docker container = &quot;name of the image you built from your dockerfile&quot;:
<ul>
<li>Hopefully you have an internal docker registry to host docker images.</li>
<li>Alternatively, you can choose Runner Type = &quot;Docker&quot; and specify the Dockerfile in your repository, but this will build the dockerfile every time.</li>
</ul>
</li>
</ul>
<h2>Build Versions and Release Notes</h2>
<p>My teammates really like this feature of FAKE. We follow the &quot;Complex Format&quot; per the <a href="https://fake.build/apidocs/v5/fake-core-releasenotes.html">FAKE release notes module documentation</a> with one small difference.</p>
<p>RELEASE_NOTES.md:</p>
<pre><code class="language-md">// FAKE's complex format
## New in 1.2.1 (Released 2019/12/24)
* stuff
* and things too

// what we do instead
## 1.2.1 - 24-Dec-2019
* stuff
* and things too
</code></pre>
<p>The version number of the artifacts are determined from the source code. The build server only provides a number that increments on each build.</p>
<p>Our build numbers follow the <code>Major.Minor.Patch.Revision</code> format where Major, Minor, and Patch are sourced using the <code>Fake.ReleaseNotes</code> module with a <code>RELEASE_NOTES.md</code> file. The Revision is the TeamCity build counter.</p>
<p>You can think of the build script as a function that takes in an argument for <code>Revision</code> and assumes it runs in a git repository. Note that anything could provide the <code>Revision</code> argument, but the build script will load that from an environment variable.</p>
<p>If you want to overly simplify a build script to a function, this is close-ish:</p>
<pre><code class="language-fsharp">FileSystem -&gt; DockerFeedConnection -&gt; NugetFeedConnection -&gt; RevisionNumber  -&gt; unit
</code></pre>
<h2>NuGet Packages</h2>
<pre><code class="language-fsharp">// testTask.IfNeeded means THIS task should run after
let nugetPackTask = BuildTask.create &quot;Artifact&quot; [ testTask.IfNeeded ] {

    let nugetPackDefaults = fun (options : NuGet.NuGetParams) -&gt;
        // tool path is by default ./tools/ or you can change it with Tools = &quot;/path/to/nuget.exe&quot;
        { options with
            Publish = true
            PublishUrl = &quot;https://artifacts.company.com/api/nuget/v3/&quot;
            // https://fake.build/dotnet-nuget.html#Creating-a-nuspec-template
            // replace placeholders in .nuspec with `NuGetParams` record field
            Version = EV.version()
            Authors = authors
            Summary = &quot;A super cool dotnet core application.&quot;
            Description = &quot;A longer description about this super cool dotnet core application.&quot;
            ReleaseNotes = release().Notes |&gt; String.toLines
            // FS0052 workaround (ugly: let x = ... in x); this is a shorthand to make an intermediate value
            Copyright = sprintf &quot;Your Company %i&quot; (let now = System.DateTime.UtcNow in now.Year)
            Tags = &quot;C#;F#;FAKE;&quot;
            Files = [   // projects deploying to kubernetes should insert their own yml file,
                        // but these files should always be packaged
                        &quot;fake.cmd&quot;, Some &quot;content&quot;, None
                        &quot;fake.sh&quot;, Some &quot;content&quot;, None
                        &quot;deploy.fsx&quot;, Some &quot;content&quot;, None
                        &quot;paket.dependencies&quot;, Some &quot;content&quot;, None
                        &quot;paket.lock&quot;, Some &quot;content&quot;, None ]
            // set paths for NuGet
            OutputPath = artifactOutDir
            WorkingDir = buildOutDir
            BasePath = Some root }

    let packApi () =
        // take the nuget pack defaults and apply API specific nuget pack settings
        NuGet.NuGet (nugetPackDefaults &gt;&gt; ApiProject.nugetPackSettings) &quot;.nuspec&quot;

    // now pack them all (could async parallel this later)
    packApi ()
}
</code></pre>
<p>If you noticed <code>ApiProject.nugetPackSettings</code>, I like to put all functions, values, paths, and names specific for a project into a project specific module in the build script.</p>
<h2>Docker Images</h2>
<pre><code class="language-fsharp">//
// Helpers
//

/// Look for the specified `tool` on the Environment's PATH and in `otherSearchFolders`.
/// - `tool` : name of the tool on a *nix system
/// - `winTool` : name of the executable on a windows system
let platformTool tool winTool otherSearchFolders =
    let tool = if Environment.isLinux then tool else winTool
    tool
    |&gt; ProcessUtils.tryFindFileOnPath
    |&gt; function
        | Some pathTool -&gt; pathTool
        | None -&gt;
            if Seq.isEmpty otherSearchFolders then
                failwithf &quot;platformTool %s not found&quot; tool
            else
                ProcessUtils.tryFindFile otherSearchFolders tool
                |&gt; function
                    | Some folderTool -&gt; folderTool
                    | None -&gt; failwithf &quot;folderTool %s not found in folders %A&quot; tool otherSearchFolders

let dockerTool =
    // you should have it installed on your development machine
    // we assume docker is included in the build agent path too
    platformTool &quot;docker&quot; &quot;docker.exe&quot; Seq.empty

let buildDocker repositoryUrl tag =
    let args = sprintf &quot;build -t %s .&quot; (repositoryUrl &lt;/&gt; tag)
    runTool &quot;docker&quot; args &quot;.&quot;

let pushDocker repositoryUrl tag =
    let args = sprintf &quot;push %s&quot; (repositoryUrl &lt;/&gt; tag)
    runTool &quot;docker&quot; args &quot;.&quot;

let dockerUser = &quot;yourcompany-user&quot;
let dockerImageName = &quot;yourcompany-api&quot;
let dockerFullName = sprintf &quot;%s/%s:%s&quot; dockerUser dockerImageName (EV.buildVersion())

let dockerBuildTask = BuildTask.create &quot;DockerBuild&quot; [] {
    buildDocker Docker.repositoryUrl dockerFullName
}
// publish the docker image
let dockerBuildTask = BuildTask.create &quot;DockerPush&quot; [dockerBuildTask] {
    pushDocker Docker.repositoryUrl dockerFullName
}

</code></pre>
<h2>Stringly vs Strongly Typed Build Targets</h2>
<h3>Stringly Typed</h3>
<p>FAKE by default has you define build targets like so:</p>
<pre><code class="language-fsharp">open Fake.Core

Target.initializeEnvironment()

// define targets
Target.create &quot;Test&quot; (fun _ -&gt;
    // run dotnet test, or whatever
)
Target.create &quot;Publish&quot; (fun _ -&gt;
    // run dotnet publish
)
Target.create &quot;Default&quot; (fun _ -&gt;
    // an empty task for default build behavior on a developer machine
)
Target.create &quot;CI&quot; (fun _ -&gt;
    // an empty task for the CI server to enter the CI specific build target ordering
)

// define ordering
&quot;Test&quot;
==&gt; &quot;Default&quot;

&quot;Default&quot;
==&gt; &quot;Publish&quot;
==&gt; &quot;CI&quot;

// if you run `fake build`, then &quot;Default&quot; will be the starting target
Target.runOrDefault &quot;Default&quot;

</code></pre>
<h3>Strongly Typed</h3>
<p><a href="https://blog.vbfox.net/2018/09/12/fake-typed-targets.html">vbfox</a> created a FAKE 5 module for <a href="https://github.com/vbfox/FoxSharp/tree/master/src/BlackFox.Fake.BuildTask">strongly-typed targets</a> that allows scripts to define let-bound values that represent build tasks, and the compiler will be able to check the usage of those targets like any other normal value.</p>
<p>I use <code>BlackFox.Fake</code>, but I miss the summary-like expression listing the order of build targets. For example:</p>
<pre><code class="language-fsharp">//// Fake.Core.Target

// define targets
Target.create &quot;Clean&quot; ()
Target.create &quot;Test&quot; ()
Target.create &quot;Publish&quot; ()
Target.create &quot;CI&quot; ()

// define ordering
&quot;Clean&quot;
==&gt; &quot;Test&quot;
==&gt; &quot;Publish&quot;

&quot;Publish&quot;
==&gt; &quot;CI&quot;

//// BlackFox.Fake.BuildTask

let cleanTask = BuildTask.create &quot;Clean&quot; [] { (* *) }
let testTask = BuildTask.create &quot;Test&quot; [clean.IfNeeded] { (* *) }
let publishTask = BuildTask.create &quot;Publish&quot; [testTask] { (* *) }
let ciTask = BuildTask.create &quot;CI&quot; [publishTask] { (* *) }
</code></pre>
<p>I do not have a clear preference or advice on what to choose over the other. I suggest trying for yourself. My day-to-day build target order is not complicated enough to show a clear difference.</p>
<h2>Creating Octopus Releases</h2>
<p>If you use something other than Octopus, chances are your deployment server has a REST API to create and deploy releases.</p>
<pre><code class="language-fsharp">
let projectName = &quot;Some Service&quot;

module DeploymentServer =

    module private EnvironmentVariables =
        let server = Environment.environVar &quot;Octopus-Server&quot;
        let apiKey = Environment.environVar &quot;Octopus-TeamCityAPIKey&quot;

    [&lt;AutoOpen&gt;]
    module private Helpers =
        // when Fake.Tools.Octo nuget package works with dotnet tool Octopus.DotNet.Cli, use Fake.Octo instead
        let octoTool cmd args =
            dotnetTool (sprintf &quot;octo %s %s --server=%s --apikey=%s&quot; cmd args EnvironmentVariables.server EnvironmentVariables.apiKey) &quot;.&quot;

    let private createReleaseArgs =
        // Using triple quotes to allow for quote characters in the format string, also could have escaped with backslash.
        // Re-use your release notes so you see them in the octopus release screen.
        sprintf &quot;&quot;&quot;--package=*:%s --project=&quot;%s&quot; --version=&quot;%s&quot; --releasenotesfile=&quot;%s&quot; &quot;&quot;&quot; buildNumber projectName buildNumber releaseNotesFile

    /// Creates a release in Octopus for this build
    let createRelease _ =
        // dotnet tool update will: 1. install if not installed, 2. same version installed, reinstall it, 3. update lower version to current version
        // This is nice because we do not have to check if the tool is already installed and conditionally NOT run `dotnet tool install` if it is. Install fails if the tool is already installed.
        // https://github.com/dotnet/cli/pull/10205#issuecomment-506847148
        dotnetTool &quot;tool update -g Octopus.DotNet.Cli&quot; &quot;.&quot;
        octoTool &quot;create-release&quot; createReleaseArgs

// make sure when this task runs that any nuget packages, docker images, etc. are already published
BuildTask.create &quot;CreateRelease&quot; [yourNugetPublishTask; yourDockerPublishTask] {
    DeploymentServer.createRelease
}
</code></pre>
<h2>VS Code Dev Containers</h2>
<p>A good way to shorten the feedback loop on your Dockerfile defining your build dependencies is to use that Dockerfile locally. VS Code's Dev Container feature makes that really easy provided you have Docker and VS Code installed.</p>
<p>I have two unsolved-by-me, but manageable, problems with this approach:</p>
<ul>
<li>.fake/ cache sometimes picks up as &quot;invalid&quot; so I have to purge the directory and download dependencies again</li>
<li>paket-files/ sometimes experiences the same behavior as .fake/</li>
</ul>
<p>I may have done something wrong with my Dockerfile/fake/paket combination. I have not investigated much because this problem does not happen often enough to waste time.</p>
<pre><code class="language-dockerfile">##
## want dotnet-sdk to use dotnet-tool and run the build script with dotnet-fake
##
FROM mcr.microsoft.com/dotnet/core/sdk:3.0-alpine
RUN apk update
# add dotnet tools to path to pick up fake and paket installation
ENV PATH=&quot;${PATH}:/root/.dotnet/tools&quot;
# install dotnet tools for fake, paket, octopus
RUN    dotnet tool install -g fake-cli \
    &amp;&amp; dotnet tool install -g paket \
# https://octopus.com/docs/octopus-rest-api/octo.exe-command-line/install-global-tool
    &amp;&amp; dotnet tool install -g Octopus.DotNet.Cli \
# install yarn
    &amp;&amp; apk add yarn \
# install docker cli; note the build server will have to provide the actual docker engine
    &amp;&amp; apk add docker \
# other tools expected by build.*.fsx scripts
    &amp;&amp; apk add git curl
# bring in the build scripts and build script dependencies files
COPY build.standalone.fsx build.webcomponents.fsx paket.dependencies paket.lock /var/app/
COPY .paket /var/app/.paket/WORKDIR /var/app
</code></pre>
<p>I publish this image to our docker registry my teammates and the build server do not need to rebuild the image every time.</p>
<h2>FAKE and Build Servers</h2>
<p>Try to write build scripts to be build server agnostic.</p>
<p>While we do not change our build server, we gain the ability to treat our build process as just another segment of code to branch, peer review, and run. I think this is much easier than using pre-defined steps and templates defined in your build server of choice.</p>
<h2>Links, Inspiration, and Contact</h2>
<p>View the other <a href="https://sergeytihon.com/2019/11/05/f-advent-calendar-in-english-2019/">F# Advent 2019 posts</a>!</p>
<p>Links:</p>
<ul>
<li><a href="https://fake.build/">FAKE</a></li>
<li><a href="https://github.com/vbfox/FoxSharp/tree/master/src/BlackFox.Fake.BuildTask">BlackFox.Fake.BuildTask</a></li>
<li><a href="https://code.visualstudio.com/docs/remote/containers#_getting-started">VS Code Dev Containers - Getting Started</a></li>
</ul>
<p>Inspiration:</p>
<p>I often reviewed these repositories to see how they used FAKE.</p>
<ul>
<li><a href="https://github.com/ionide/ionide-vscode-fsharp">Ionide</a></li>
<li><a href="https://github.com/SAFE-Stack/SAFE-BookStore">SAFE Stack BookStore</a></li>
</ul>
<p>Contact:</p>
<p>I do not have a comments section, so please use <a href="https://twitter.com/garthfritz/">@garthfritz on Twitter</a> or <code>@garth</code> on the <a href="https://fsharp.org/guides/slack/">F# Software Foundation Slack</a> to contact me with feedback or clarification.</p>

        </article>
        <article class="post">
          <h1 class="post-title">
            <a href="/posts/2018-12-13-fsadvent-2018-fake.html">
              FsAdvent 2018 - Getting My Team Hooked on FAKE
            </a>
          </h1>
          <div class="post-date">
            12/13/2018
          </div>
          <p><strong>This is a post for <a href="https://sergeytihon.com/2018/10/22/f-advent-calendar-in-english-2018/">F# Advent 2018</a>.</strong></p>
<p>This post will describe the things that got my team hooked on <a href="https://fake.build/">FAKE</a> - an F# DSL for Build Tasks and more. This will be more narrative and opinions than F# code. Sorry.</p>
<hr />
<blockquote>
<p>&quot;If a company says they are a &quot;.NET shop&quot;, what they really mean is &quot;we are a C# shop, .NET is C#, stop talking to me about F#&quot;.</p>
</blockquote>
<p>— Me, ranting in my 1 on 1 meetings with my manager</p>
<p>I have been pushing F# on my coworkers since I started in June 2017. Lots of things got thrown onto the wall, and the things that actually shipped were one project with JSON and WSDL Type Providers and, yesterday, a project built completely by FAKE (also has JSON and CSV Type Providers).</p>
<p><strong>Disclaimer</strong>, these are opinions and are listed in no particular order. If you have any feedback, need some clarification, or want to tell me I'm completely wrong, the best place to start will be <a href="https://twitter.com/garthfritz">Twitter</a>.</p>
<h3>Things My Team Liked About FAKE</h3>
<h4>Feel Like a Command Line Wizard Again</h4>
<p>If using FAKE makes developers have fun scripting building, testing, and packaging processes, then that is a win all by itself. Bonus points if it makes them feel like a cool kid.</p>
<p>The <a href="https://fake.build/fake-dotnetcore.html#Getting-Started">FAKE dotnet global tool</a> helps with that too.</p>
<p><img src="https://user-images.githubusercontent.com/2267030/49901976-b26a5b00-fe30-11e8-8383-02b6dde9e08f.png" alt="Image of are you a wizard" /></p>
<h4>Freedom to Script as Much of Build and Deploy as You Want</h4>
<ul>
<li>the way you build locally is how the build server builds</li>
</ul>
<p>We have the build server - TeamCity but it could just as well be another - provide the full build number and move our build artifacts to our internal package feed. Everything else is done in the script.</p>
<p>A developer can try different build configurations locally without messing up the project build configuration on the build server. Most of the benefits under this reason are the same benefits as putting any other code into source control.</p>
<p>The biggest win is how short the feedback cycle is for building. How quickly can you debug a build error with a particular TeamCity build step? Probably not as fast as you could on your own machine. Don't you normally remote or ssh into the problem build agent if the error log doesn't make sense anyway?</p>
<h4>FAKE Features Make Annoying Things Easy</h4>
<p>I have my favorite FAKE features, but these are the top ones according to my newly converted team.</p>
<ul>
<li>Super easy templating of .nuspec parameters</li>
</ul>
<p>We apply the same NuGet package attributes to every assembly, so it was really easy to just let FAKE do that for us. All you have to do is substitute the values you care about and the NuGet required minimum fields.</p>
<p><a href="https://fake.build/dotnet-nuget.html#Setting-up-the-build-script">Example customizing FAKE's default nuspec.</a></p>
<ul>
<li>Release Notes automatically pulled from the latest version in the Release Notes file</li>
</ul>
<p>I don't think any of our projects publish developer written release notes, but FAKE makes it easy to publish them in the NuGet package Release Notes field. I think release notes from the developer are a good idea.</p>
<p><a href="https://fake.build/apidocs/v5/fake-core-releasenotes.html">FAKE's ReleaseNotes Sample</a></p>
<blockquote>
<p>&quot;I still don't love functional or F# for my day-to-day work, but I'll be damned if FAKE and Type Providers aren't my favorite things right now.&quot;</p>
</blockquote>
<p><img src="https://user-images.githubusercontent.com/2267030/49901909-7c2cdb80-fe30-11e8-987e-cae2a3545ab0.png" alt="Image of FAKE and Type Providers are my favorite things" /></p>
<h3>Things My Team (and others) Did Not Like About FAKE</h3>
<p>I will use the following pattern to list the concerns:</p>
<ul>
<li>the problem/concern someone has
<ul>
<li>my not necessarily nuanced retort</li>
</ul>
</li>
</ul>
<p>Here we go:</p>
<ul>
<li>Syntax is jarring (aka syntax shock).
<ul>
<li>I think you mean &quot;is not C# syntax&quot;. Well so is HTML, CSS, SQL, JavaScript, Powershell, Bash, but you can do all of those!</li>
</ul>
</li>
<li>Who will train and help other people to be familiar with F# if this becomes standard?
<ul>
<li>Me. Duh.</li>
</ul>
</li>
<li>Can't you just do all of this stuff in TeamCity and Octopus already? That's why we bought it.
<ul>
<li>Sounds like sunk cost fallacy to me.</li>
<li>If you want finer grained control over your build, I don't think that canned TeamCity steps will are enough.</li>
<li>I think FAKE's Target Dependency Ordering is more powerful and developer-friendly than standing up multiple TeamCity build configurations.</li>
<li>Isn't writing code a big part of your job? Why do you prefer clicking and dragging boxes in a TeamCity/Octopus screen over writing code?</li>
</ul>
</li>
</ul>
<h3>How Did I Do It?</h3>
<p>I tested out FAKE near the end of its FAKE 4 lifetime. Once FAKE updated to version 5 I tried to script the build for one of our big legacy applications. I did not get very far. It was way too much process to replace at once, and I could not present F# or FAKE in a good light with a partially migrated build.</p>
<p>Fortunately, I found an NDC talk <a href="https://www.youtube.com/watch?v=_sZT0CpJ6Vo">Immutable application deployments with F# Make - Nikolai Norman Andersen</a> and Nikolai's sample <a href="https://github.com/nikolaia/weather-in-harstad">weather-in-harstad repository</a> which put me on the path of making a coherent argument and demo build script for the team. I encourage you to watch Nikolai's talk in full. I'll even repeat the link at the end.</p>
<p>Some weeks later, we start two greenfield projects - one large in scope and one small. Here's the &quot;secret&quot; way I got FAKE into the build - I just did it. F# first, ask questions (or forgiveness) later, except this time it worked.</p>
<h3>Future Work</h3>
<p>Due to priorities changing frequently, we have not had time to use FAKE to script our deploy process and post-deployment smoke testing. The team and I still really want to do that, but time constraints unfortunately make it smarter to just let Octopus do it's job.</p>
<p>Other than time constraints, I want to do some preparation work to confidently demo a solid FAKE deploy script to the team.</p>
<ol>
<li>
<p>How should I pull out all of the non-sensitive variables out of Octopus and into the FAKE script?</p>
</li>
<li>
<p>Same as #1 but for the sensitive variables (API keys, Production level credentials, etc.)?</p>
<p>Nikolai demonstrated using <a href="http://git-secret.io/">git-secret</a> to accomplish it, but he was hesitant to recommend it. So that's why I need to research it more.</p>
</li>
<li>
<p>How do I safely and unobtrusively transform all of the former Octopus variables to their environment specific values?</p>
<p>I don't think anyone likes having pages and pages of Octopus variables. I am certain FAKE can provide an elegant alternative. I just need to work on it more.</p>
</li>
<li>
<p>How can I make #1-3 easy for the rest of the team to maintain and develop?</p>
</li>
<li>
<p>How do I reliably share any bespoke deployment tasks we make with other teams via Octopus?</p>
</li>
</ol>
<p>If any of these problems sound really easy to you or you have already solved them using FAKE, <a href="https://twitter.com/garthfritz">please let me know</a>!</p>
<p>You should watch <a href="https://www.youtube.com/watch?v=_sZT0CpJ6Vo">Immutable application deployments with F# Make - Nikolai Norman Andersen</a>.</p>

        </article>
        <article class="post">
          <h1 class="post-title">
            <a href="/posts/2017-02-22-crm-plugin-clear-fields.html">
              Clearing Entity Fields in Early Bound Plugin Code
            </a>
          </h1>
          <div class="post-date">
            2/22/2017
          </div>
          <p>If you try to <code>NULL</code> the value of an Entity field and save that change with the CRM OrganizationServiceContext, you need to be careful how you set that NULL value.  If the field to NULL is not in the <code>myEntity.Attributes</code> collection, then it will not be updated when the service call updates the record in CRM.</p>
<p>We can demonstrate this by initializing the early bound Account entity in a few different ways and inspecting the Attribute collection.  The field to clear in this example will be <code>ParentAccountId</code>.</p>
<p><strong>First</strong>, we will use the constructor then NULL with dot notation.</p>
<p><strong>Second</strong>, we use the object initializer syntax and null with that.</p>
<p><strong>Third</strong>, we initialize only the ID field and use dot notation to set the field NULL.</p>
<p>These attempts will not put ParentAcountId into the Attributes collection.  Two ways that will work are setting the field to NULL with the late bound class, and initializing or setting ParentAccountId with a dummy non-NULL value in the early bound class then setting the field to NULL.</p>
<p>This test class will demonstrate each of these approaches.</p>
<pre><code class="language-c#">using Microsoft.VisualStudio.TestTools.UnitTesting;
using Microsoft.Xrm.Sdk;
using MyXRM.Entities;
using System;
using System.Collections.Generic;
using System.Linq;

namespace MyXRM.Tests
{
    [TestClass]
    public class AttributeCollectionTest
    {
        [TestMethod]
        public void TestWhatAddsAttributeToCollection()
        {
            // set up the account to reference
            var myAccountInCRM = new Account();
            myAccountInCRM.Id = Guid.NewGuid();
            myAccountInCRM.Name = &quot;Test Name&quot;;
            myAccountInCRM.ParentAccountId = new EntityReference(Account.EntityLogicalName, Guid.NewGuid());
            Assert.IsTrue(myAccountInCRM.Attributes.ContainsKey(&quot;parentaccountid&quot;));

            // list of pass/fails for each attempt
            var results = new List&lt;bool&gt;();

            /*
             * Below are different ways of initializing the early bound Account entity
             * with the field we want to clear.
             */

            // 
            var withConstructor = new Account();
            withConstructor.Id = myAccountInCRM.Id;
            withConstructor.ParentAccountId = null;
            results.Add(withConstructor.Attributes.ContainsKey(&quot;parentaccountid&quot;));

            var withInitializer = new Account
            {
                Id = myAccountInCRM.Id,
                ParentAccountId = null
            };
            results.Add(withInitializer.Attributes.ContainsKey(&quot;parentaccountid&quot;));

            var withInitializedId_ThenUpdate = new Account
            {
                Id = myAccountInCRM.Id
            };
            withInitializedId_ThenUpdate.ParentAccountId = null;
            results.Add(withInitializedId_ThenUpdate.Attributes.ContainsKey(&quot;parentaccountid&quot;));

            var lateBound = new Entity
            {
                Id = myAccountInCRM.Id
            };
            lateBound[&quot;parentaccountid&quot;] = null;
            results.Add(lateBound.Attributes.ContainsKey(&quot;parentaccountid&quot;));

            var withInitializer_ActuallyClearsField = new Account
            {
                Id = myAccountInCRM.Id,
                ParentAccountId = new EntityReference()
            };
            withInitializer_ActuallyClearsField.ParentAccountId = null;
            results.Add(withInitializer_ActuallyClearsField.Attributes.ContainsKey(&quot;parentaccountid&quot;));

            Console.WriteLine(&quot;Test Results: {0}&quot;,
                String.Join(&quot;,&quot;, results));
            Assert.IsTrue(results.Count(x =&gt; x == true) == 2,
                &quot;Only two of these cases should have passed.&quot;);
            Assert.IsTrue(results[results.Count - 2],
                &quot;The late bound example should have been true&quot;);
            Assert.IsTrue(results.Last(),
                &quot;The last result should have been true in this demo.&quot;);
        }
    }
}
</code></pre>
<p>In this case, <strong>using the late bound entity is more straightforward</strong> than using the early bound entity.  With late bound you will not get intellisense so make sure you have the correct spelling and casing for your field.  You can find the correct string to use in your early bound entities file by hitting F12 on the early bound field and inspecting the method decorator.  For our field, we use the string in here: <code>[Microsoft.Xrm.Sdk.AttributeLogicalNameAttribute(&quot;parentaccountid&quot;)]</code>.</p>
<p>If you use the <a href="https://github.com/daryllabar/DLaB.Xrm.XrmToolBoxTools/releases">Early Bound Generator tool</a> from the <a href="http://www.xrmtoolbox.com/">XRM Toolbox</a>, one particularly useful thing it does is enumerates each attribute name as a struct of strings.  That provides intellisense and the correctly cased string name of the field.</p>
<p>Initializing an early bound entity field with NULL looks like code that should work, but chances are you only notice the problem when the update does not clear that field in CRM.  You could just as easily do <code>earlyBoundAccount[&quot;parentaccountid&quot;] = null;</code>, but why would that be your first choice when you have early bound classes?</p>
<p>You might consider a wrapper class to handle this NULL setting logic for you, or probably simpler still an extension method <code>SetToNull(myAccount, &quot;nameOfFieldToClear&quot;)</code> so you can use this for all entities.  Remember to use the <code>Fields</code> struct if you use the Early Bound Generator to create your early bound classes - <code>SetToNull(myAccount, Account.Fields.NameOfFieldToClear)</code>.</p>

        </article>
        <article class="post">
          <h1 class="post-title">
            <a href="/posts/2016-08-22-deactivate-record-bug.html">
              CRM 2016 Deactivate Record on Form With Emtpy Required Fields Bug and Workaround
            </a>
          </h1>
          <div class="post-date">
            8/22/2016
          </div>
          <h3>Summary</h3>
<h4>Problem:</h4>
<p>If an entity record is missing required fields, you get an error when trying to deactivate the record from the form.</p>
<h4>Solution Summary</h4>
<p>I assume you know how to use RibbonWorkbench to edit entity ribbons so I gloss over the setup specifics.  Review the <a href="%22https://ribbonworkbench.uservoice.com/knowledgebase/articles/71374-1-getting-started-with-the-ribbon-workbench%22">Getting Started Guide at the author's website</a> and the <a href="%22http://develop1.net/public/post/Ribbon-Workbench-2016-Beta.aspx%22">CRM 2016 RibbonWorkbench beta announcement post</a> for more information about Ribbon Workbench.</p>
<ol>
<li>Open a solution containing the entities you want to fix in Ribbon Workbench.</li>
<li>Add a Custom Javascript Action <strong>above</strong> the existing Custom Javascript Action.  Our new action must execute first.</li>
<li>Have the action call a function that does the following:
<ol>
<li>Remove the required level from all form fields then return. This must be synchronous code because the next Action will execute immediately after the first action returns.  It should remember which fields were required if you want to restore them after <code>statecode</code> changes.</li>
<li><em>(optional)</em> add an OnChange event to the <code>statecode</code> attribute (make sure this is on the form) to restore the required level to the correct attributes.</li>
</ol>
</li>
<li>Publish the solution from Ribbon Workbench.</li>
</ol>
<hr />
<h3>Solution/Workaround, Longer Form</h3>
<p>In CRM 2016, <a href="https://community.dynamics.com/crm/f/117/t/117841">and similarly for others in 2013+</a>, we ran into an odd error around deactivating Accounts and Contacts from their forms.  This likely can happen on any record having a Deactivate button.  If a Contact record is missing a required field denoted by a red asterisk (*), then clicking the Deactivate button and completing the popup window by clicking OK, you get a not so helpful error message:</p>
<p><img src="https://i.imgur.com/RZGPVLx.png" alt="Popup saying An Error has occurred. Please return to the home page and try again." title="A really vague CRM error message" /></p>
<p>The obscured window is the &quot;Confirm Deactivation&quot; CRM lightbox.</p>
<p>If you fill in the required fields and try again (with or without saving the form), then the Deactivate button click works.  Deactivating the record from a homepage grid or subgrid works regardless of the required fields.  The grid approach does not need required fields to be filled.  Why does the form need it?  Since the required fields were the apparent blockers, I thought the button was changing the statecode and statuscode fields, saving the form, and failing because you can't save the form when required fields are empty.  We have to see how the Deactivate button works, and I used <a href="%22https://community.dynamics.com/crm/b/develop1/archive/2016/04/25/ribbon-workbench-2016-beta%22">Ribbon Workbench for CRM 2016 (beta)</a> to see the function name I need to find.</p>
<p><img src="https://i.imgur.com/GbvTDwn.png" alt="Deactivate Account form button in Ribbon Workbench" /></p>
<p>The bottom right <strong>Custom Javascript Action</strong> is what an uncustomized Deactivate Button command does when clicked. Ignore the action above it for now - it is the workaround I will describe later.</p>
<p>The RibbonWorkbench showed me the library and function the Deactivate button calls - <code>CommandBarActions.js</code> and <code>Mscrm.CommandBarActions.changeState</code>. If I am on the Account form, the button calls <code>Mscrm.CommandBarActions.changeState(&quot;deactivate&quot;, &quot;{my-account-guid}&quot;, &quot;account&quot;)</code>. At the end of this post is the code that I followed while trying to mentally trace what happens when Deactivate is clicked in our scenario. It is not the full <code>CommandBarActions.js</code> file. I do not find a definitive answer, but if you want to read the optional ramblings, follow the comments from top to bottom in this code block. It is suffice to know that empty required fields are the root of the problem that we can fix.</p>
<p>I think this is a bug in CRM 2016 forms, but we can work around it in a supported way.  I wonder why the form does not do a <a href="%22https://msdn.microsoft.com/en-us/library/dn932124.aspx%22">specialized UpdateRequest</a> (fancy name for &quot;just update the statecode and statuscode in the UpdateRequest&quot;) through REST or WebApi?  It might be on a backlog somewhere.</p>
<p>Check the top right Custom Javascript Action again.  Notice the Custom Javascript Action called <code>deactivateFromFormWorkaround</code> taking <code>PrimaryEntityTypeName</code> as a parameter.  This will temporarily remove the required level from required fields so deactivating from the form will complete.</p>
<p><img src="https://i.imgur.com/GbvTDwn.png" alt="Custom Javascript Action Workaround with Ribbon Workbench" /></p>
<pre><code class="language-js">// Remove Required Level from Fields so Deactivate Works on CRM 2016 form, then restore after the statecode changes 

// XrmCommon.removeOnChange and XrmCommon.addOnChange call the same Xrm.Page methods but check if the field exists on the form first.

// CommandProperties is always passed as the first parameter in Ribbon Button Actions
function deactivateFromFormWorkaround(CommandProperties, PrimaryEntityTypeName) {
    var restoreRequiredFields = function (context) {
        XrmCommon.undoRemoveRequiredLevel();
        XrmCommon.removeOnChange(&quot;statecode&quot;, restoreRequiredFields);
    };
    var permittedEntities = [&quot;account&quot;, &quot;contact&quot;];
    if (permittedEntities.indexOf(PrimaryEntityTypeName) === -1) {
        console.error(PrimaryEntityTypeName + &quot; is not supported for this Deactivate button workaround.&quot;);
    }
    XrmCommon.removeRequiredLevel();
    XrmCommon.addOnChange(&quot;statecode&quot;, restoreRequiredFields);
}

// XrmCommon is normally in another js file, so I'm adding just the relevant code to this gist.
var XrmCommon = XrmCommon || {};

XrmCommon._requiredFields = [];
XrmCommon.removeRequiredLevel = function () {
    /// &lt;summary&gt;Removes required level from all required fields&lt;/summary&gt;
    Xrm.Page.getAttribute(function (attribute, index) {
        if (attribute.getRequiredLevel() == &quot;required&quot;) {
            attribute.setRequiredLevel(XrmCommon.CONSTANTS.FORM_REQUIRED_LEVEL_NONE);
            XrmCommon._requiredFields.push(attribute.getName());
        }
    });
}
XrmCommon.undoRemoveRequiredLevel = function () {
    if (XrmCommon._requiredFields.length == 0) {
        _xrmCommonConsoleWarning(&quot;Nonsensical call to XrmCommon.undoRemoveRequiredLevel without calling XrmCommon.removeRequiredLevel first&quot;);
    }
    else {
        var affectedFieldNames = XrmCommon._requiredFields;
        for (var name in affectedFieldNames) {
            XrmCommon.setFieldRequirementLevel(affectedFieldNames[name], XrmCommon.CONSTANTS.FORM_REQUIRED_LEVEL_REQUIRED);
        }
        XrmCommon._requiredFields.length = 0;
    }
}
XrmCommon.CONSTANTS = {
    FORM_REQUIRED_LEVEL_NONE: &quot;none&quot;,
    FORM_REQUIRED_LEVEL_RECOMMENDED: &quot;recommended&quot;,
    FORM_REQUIRED_LEVEL_REQUIRED: &quot;required&quot;
};
</code></pre>
<p>This code could have instead done a Metadata query to retrieve which fields are required for this form. The SDK javascript libraries do asynchronous calls, and you can modify the functions to add a parameter to make them synchronous calls if you want. I think the presented approach is simpler and definitely less code. You do not have to restore the required levels as it is just a cleanup step.</p>
<p><strong>One problem with this approach</strong> is if the user cancels the Deactivate confirmation, then the formerly required fields will still be not required.</p>
<p>That's it! Hopefully updates to CRM fix this weird behavior.</p>
<h3>CRM Javascript and Ramblings</h3>
<p>This is the code block referenced above.</p>
<pre><code class="language-js">// SUMMARY if you don't want to read the whole thing
// If this branch is followed and does the return &quot;if (!Xrm.Page.data.getIsValid()) return;&quot;, 
//      then I think the &quot;please try again&quot; popup happens because &quot;Xrm.Page.data.save($v_5).then($v_0, $v_1)&quot; has a problem.
// Otherwise, I think the &quot;please try again&quot; popup happens because getIsValid makes this command return earlier than expected
// I find the specific message defined as the global variable LOCID_IPADWINCLOSED,
// but I don't find how calling Mscrm.CommandBarActions.changeState() directly from the ribbon in this scenario throws that message.

// clicking on Account form calls: Mscrm.CommandBarActions.changeState(&quot;deactivate&quot;, &quot;{my-account-guid}&quot;, &quot;Account&quot;)
Mscrm.CommandBarActions.changeState = function(action, entityId, entityName) {
    Mscrm.CommandBarActions.handleStateChangeAction(action, entityId, entityName)
};
Mscrm.CommandBarActions.handleStateChangeAction = function(action, entityId, entityName) {
    var $v_0 = null;
    if (Mscrm.CommandBarActions.isWebClient() || Xrm.Page.context.client.getClient() === &quot;Outlook&quot;) {
        $v_0 = new Xrm.DialogOptions;
        $v_0.height = 230;
        $v_0.width = 600
    }
    // entityName = &quot;account&quot; makes this if guard false,
    if (Mscrm.InternalUtilities.DialogUtility.isMDDConverted(action, entityName)) {
        var $v_1 = new Microsoft.Crm.Client.Core.Storage.Common.ObjectModel.EntityReference(entityName, new Microsoft.Crm.Client.Core.Framework.Guid(entityId)),
            $v_2 = [$v_1],
            $v_3 = {};
        $v_3[&quot;records&quot;] = Mscrm.InternalUtilities.DialogUtility.serializeSdkEntityReferences($v_2);
        $v_3[&quot;action&quot;] = action;
        $v_3[&quot;lastButtonClicked&quot;] = &quot;&quot;;
        $v_3[&quot;state_id&quot;] = -1;
        $v_3[&quot;status_id&quot;] = -1;
        Xrm.Dialog.openDialog(&quot;SetStateDialog&quot;, $v_0, $v_3, Mscrm.CommandBarActions.closeSetStateDialogCallback, null)
    } else {
        $v_0.height = 250;
        $v_0.width = 420;
        var $v_4 = Xrm.Internal.getEntityCode(entityName),
            $v_5 = Mscrm.GridCommandActions.$L(action, $v_4, 1);
        $v_5.get_query()[&quot;iObjType&quot;] = $v_4;
        $v_5.get_query()[&quot;iTotal&quot;] = &quot;1&quot;;
        $v_5.get_query()[&quot;sIds&quot;] = entityId;
        $v_5.get_query()[&quot;confirmMode&quot;] = &quot;1&quot;;
        var $v_6 = [action, entityId, entityName],
            $v_7 = Mscrm.CommandBarActions.createCallbackFunctionFactory(Mscrm.CommandBarActions.performActionAfterChangeStateWeb, $v_6);
        // $v_6 is the args array to performActionAfterChangeStateWeb, so now check what that function does
        // when $v_6 = [&quot;deactivate&quot;, &quot;{my-account-guid}&quot;, &quot;account&quot;]
        Xrm.Internal.openDialog($v_5.toString(), $v_0, [entityId], null, $v_7)
    }
};
Mscrm.InternalUtilities.DialogUtility.isMDDConverted = function(action, entityName) {
    switch (action) {
        case &quot;activate&quot;:
            switch (entityName) {
                case &quot;audit&quot;:
                case &quot;campaignresponse&quot;:
                case &quot;channelaccessprofilerule&quot;:
                case &quot;contract&quot;:
                case &quot;service&quot;:
                case &quot;sla&quot;:
                case &quot;systemuser&quot;:
                case &quot;workflow&quot;:
                    return false
            }
            break;
        case &quot;deactivatecampactivity&quot;:
            return false;
        case &quot;deactivate&quot;:
            switch (entityName) {
                case &quot;audit&quot;:
                case &quot;campaignresponse&quot;:
                case &quot;channelaccessprofilerule&quot;:
                case &quot;contract&quot;:
                case &quot;service&quot;:
                case &quot;sla&quot;:
                case &quot;systemuser&quot;:
                case &quot;workflow&quot;:
                    return false
            }
            break;
        case &quot;delete&quot;:
            switch (entityName) {
                case &quot;audit&quot;:
                case &quot;service&quot;:
                case &quot;workflow&quot;:
                case &quot;hierarchyrule&quot;:
                    return false
            }
            break;
        case &quot;converttoopportunity&quot;:
            switch (entityName) {
                case &quot;serviceappointment&quot;:
                    return false
            }
            break;
        case &quot;converttocase&quot;:
            switch (entityName) {
                case &quot;serviceappointment&quot;:
                    return false
            }
            break;
        case &quot;assign&quot;:
            switch (entityName) {
                case &quot;connection&quot;:
                case &quot;duplicaterule&quot;:
                case &quot;emailserverprofile&quot;:
                case &quot;goal&quot;:
                case &quot;goalrollupquery&quot;:
                case &quot;importmap&quot;:
                case &quot;mailbox&quot;:
                case &quot;mailmergetemplate&quot;:
                case &quot;postfollow&quot;:
                case &quot;queue&quot;:
                case &quot;report&quot;:
                case &quot;serviceappointment&quot;:
                case &quot;sharepointdocumentlocation&quot;:
                case &quot;sharepointsite&quot;:
                case &quot;workflow&quot;:
                    return false
            }
            break
    }
    return true
};
Mscrm.CommandBarActions.createCallbackFunctionFactory = function(func, parameters) {
    return function(retValue) {
        parameters.unshift(retValue);
        return func.apply(null, parameters)
    }
};
Mscrm.CommandBarActions.performActionAfterChangeStateWeb = function(returnInfo, action, entityId, entityName) {
    var $v_0 = -1,
        $v_1 = 0;
    if (!Mscrm.InternalUtilities.JSTypes.isNull(returnInfo) &amp;&amp; returnInfo) {
        var $v_2 = returnInfo;
        // $1U is a parseInt wrapper, so I'm not including it
        $v_0 = Mscrm.CommandBarActions.$1U($v_2[&quot;iStatusCode&quot;]);
        $v_1 = Mscrm.CommandBarActions.$1U($v_2[&quot;iStateCode&quot;]);
        // performActionAfterStateChange(&quot;deactivate&quot;, &quot;{my-account-guid}&quot;, &quot;account&quot;, newStateCodeFromDeactivateDialog, newStatusCodeFromDeactivateDialog, probablyReturnObject)
        Mscrm.CommandBarActions.performActionAfterStateChange(action, entityId, entityName, $v_1, $v_0, $v_2)
    }
};
Mscrm.CommandBarActions.performActionAfterStateChange = function(action, entityId, entityName, stateCode, statusCode, result) {
    var $v_0 = 0;
    switch (entityName) {
        // 
        case &quot;account&quot;:
        case &quot;contact&quot;:
        case &quot;pricelevel&quot;:
        case &quot;recommendationmodel&quot;:
        case &quot;systemuser&quot;:
        case &quot;topicmodel&quot;:
        case &quot;knowledgesearchmodel&quot;:
            if (action === &quot;activate&quot;) {
                stateCode = 0;
                Xrm.Page.context.saveMode = 6
            } else if (action === &quot;deactivate&quot;) {
                stateCode = 1;
                // this is our entityName and action
                // but I don't know what saveMode = 5 does when required fields are empty
                // doesn't seem to do anything different when run in the console... moving down
                Xrm.Page.context.saveMode = 5
            }
            break;
        case &quot;entitlement&quot;:
            if (action === &quot;activate&quot;) stateCode = 1;
            else if (action === &quot;deactivate&quot;) stateCode = 0;
            break;
        case &quot;campaignactivity&quot;:
            if (action === &quot;deactivatecampactivity&quot;) {
                $v_0 = 5;
                var $v_1 = new Mscrm.CampaignActivityStateHandler;
                $v_1.setDates(result[&quot;iStartDate&quot;], result[&quot;iEndDate&quot;]);
                $v_1.updateState()
            }
            break
    }
    if (action === &quot;activate&quot;) $v_0 = 6;
    else if (action === &quot;deactivate&quot;) $v_0 = 5;
    Xrm.Page.context.saveMode = $v_0;
    // setState calls $14 so it's a non-trivial enough wrapper to include here
    Mscrm.CommandBarActions.setState(entityId, entityName, stateCode, statusCode)
};
Mscrm.CommandBarActions.setState = function(entityId, entityName, stateCode, statusCode, closeWindow, entityToOpen, entityIdToOpen) {
    if (Mscrm.InternalUtilities.JSTypes.isNull(Xrm.Page.data.entity.getId())) return;
    // getIsValid is not documented, so I can't assume it checks required fields are filled, but I _think_ it does...
    // but this seems like a controlled return and not something that would make the popup &quot;an error has occurrend please go the the homepage and try again&quot;
    // I can't find the source of getIsValid() so I assume it returns true if required fields are empty
    if (!Xrm.Page.data.getIsValid()) return;
    // I think this is CRM trying to match your chosen statusCode to a stateCode
    // I assume the Confirm Deactivation lightbox picks only the StatusCode
    // either way, $14 still gets called so I don't think I need to include this setState function to read through
    // now look at $14
    if (typeof statusCode === &quot;undefined&quot;) statusCode = -1;
    else if (stateCode === -1) {
        Xrm.Internal.getStateCodeFromStatusOption(entityName, statusCode).then(function($p1_0) {
            stateCode = $p1_0;
            Mscrm.CommandBarActions.$14(entityId, entityName, stateCode, statusCode, closeWindow, entityToOpen, entityIdToOpen)
        }, function() {
            Mscrm.CommandBarActions.$14(entityId, entityName, stateCode, statusCode, closeWindow, entityToOpen, entityIdToOpen)
        });
        return
    }
    Mscrm.CommandBarActions.$14(entityId, entityName, stateCode, statusCode, closeWindow, entityToOpen, entityIdToOpen)
};
// I think the dive finally ends here
// $v_0 seems to be the actual deactivate via Xrm.Internal.messages.setState()
Mscrm.CommandBarActions.$14 = function($p0, $p1, $p2, $p3, $p4, $p5, $p6) {
    var $v_0 = function($p1_0) {
            if (!$p0 || !$p0.length) $p0 = Xrm.Page.data.entity.getId();
            // if I'm on the web on a form, then I think this if guard is false
            // so we go to the else branch!
            if (Xrm.Utility.isMocaOffline()) {
                var $v_2 = new Microsoft.Crm.Client.Core.Storage.Common.ObjectModel.EntityReference($p1, new Microsoft.Crm.Client.Core.Framework.Guid($p0)),
                    $v_3 = new Microsoft.Crm.Client.Core.Storage.DataApi.Requests.SetStateRequest($v_2, $p2, $p3, true),
                    $v_4 = function() {
                        Mscrm.CommandBarActions.$1q($p0, $p1, $p4, $p5, $p6)
                    };
                Xrm.Utility.executeNonCudCommand(&quot;SetState&quot;, $p1, $v_3, $v_4, Mscrm.InternalUtilities.ClientApiUtility.actionFailedCallback)
            // looks like Xrm.Internal.messages.setState is a promise function
            // I assume setState works fine, but $1q tries to figure out what to do with the UI after the promise completes successfully
            // ALTHOUGH, $v_0 does not even get called until the form saves successfully... so lets go to Xrm.Page.data.save($v_5)
            } else Xrm.Internal.messages.setState($p1, $p0, $p2, $p3).then(function($p2_0) {
                Mscrm.CommandBarActions.$1q($p0, $p1, $p4, $p5, $p6)
            }, function($p2_0) {
                Mscrm.CommandBarActions.$O = false;
                Mscrm.InternalUtilities.ClientApiUtility.actionFailedCallback($p2_0)
            })
        },
        $v_1 = function($p1_0) {
            Mscrm.CommandBarActions.$O = false
        };
    if (!Mscrm.CommandBarActions.$O) {
        Mscrm.CommandBarActions.$O = true;
        var $v_5 = new Xrm.SaveOptions;
        $v_5.useSchedulingEngine = false;
        // I don't see why but maybe the save throws an error?  Otherwise, it might actually be .getIsValid returning early
        // that makes the message throw.
        Xrm.Page.data.save($v_5).then($v_0, $v_1)
    }
};
</code></pre>

        </article>
        <article class="post">
          <h1 class="post-title">
            <a href="/posts/2016-08-19-set-values-in-relationship-mappings.html">
              CRM 2016 Set Non-Mapped Values in Relationship Mappings
            </a>
          </h1>
          <div class="post-date">
            8/19/2016
          </div>
          <h3>Requirement</h3>
<p>Replace freetext Assistant fields on the Contact form with a referential 1:N Contact relationship lookup field. Freetext fields for Assistant are not convenient enough.</p>
<h3>Summary of Steps</h3>
<ol>
<li>Create a new Contact lookup field, refrential relationship type.</li>
<li>Notice that the default set of field mappings will default the Assistant field to the Contact you are creating the Assistant from.</li>
<li>Register and fire an OnChange event in the Quick Create form OnLoad event to check the Assistant GUID against the CreateFromId from QueryStringParameters.</li>
<li>If the GUIDs match, then you know this form is being used to create an Assistant.</li>
<li>Add JavaScript to the Assistant OnChange that runs when the GUIDs match to do other Assistant-only defaulting that the Relationship Mappings cannot do (or if non-mapped fields should not be changed by the user, then register a Pre-Create of Contact event plugin to set them instead of this JavaScript).</li>
</ol>
<h3>Walkthrough</h3>
<p>When creating a new lookup field, you have to create a new relationship.  CRM will generate a set of default mappings for new relationships.  We wanted to use a lookup to another Contact record instead of using the freetext fields &quot;Assistant&quot;, &quot;Assistant Email&quot;, and &quot;Assistant Phone&quot; on a Contact.</p>
<p><img src="https://i.imgur.com/o5f21cn.png" alt="Assistant Freetext Fields to replace with a Contact Lookup" /></p>
<p>In our example, we have created a 1:N relationship from Contact to Contact for a field called Assistant. Any fields in the mappings list will populate onto the Create form for you. If you want to use this defaulting in plugin code, you have to use the <a href="https://msdn.microsoft.com/en-us/library/microsoft.crm.sdk.messages.initializefromrequest.aspx%22">InitializeFromRequest</a> or <a href="https://msdn.microsoft.com/en-us/library/mt683533.aspx">WebApi InitializeFrom function</a>. One of the automatic field mappings defaults the Assistant field of the new record to the Contact from which it is being created. This is a bad default because it is a circular reference, and CRM complains about it when you try to save the form. If Assistant was not on the create form, this probably would not happen. Our requirement specifically wants the field on the form though.</p>
<p><img src="https://i.imgur.com/cpJpVNj.png" alt="ContactId to Assistant Mapping You Cannot Change" /></p>
<p>We enabled the Contact entity for Quick Create forms, and the Assistant field is on the Quick Create form.  CRM does not let you delete or modify that relationship mapping so we have to do some client-side validation.  Add an OnChange event to the Assistant field and fire it in the OnLoad event of the Quick Create form.  The relationship populates the fields before OnLoad fires.  The OnChange event should clear the Assistant field if the GUID of the Assistant lookup matches the GUID of the source Contact record.  In a Quick Create form launched from a lookup field, you can get the source GUID from <code>Xrm.Page.context.getQueryStringParameters()._CreateFromId</code>.</p>
<p>If I am creating an Assistant for my Contact named &quot;test, testington&quot;, then this is what the QueryStringParameters return object looks like.  Hit F12 when the Quick Create form is open then type that code - <code>frames[0]</code> or <code>frames[1]</code> might be necessary if the <code>Xrm.Page</code> object is sort of empty.
<img src="https://i.imgur.com/JabCMpI.png" alt="GetQueryStringParameters example" /></p>
<pre><code class="language-js">// JavaScript for setting defaults on a Quick Create form launched from a new Assistant lookup field 

function quickCreateStartLoad() {
    if (XrmCommon.getFormType() === XrmCommon.CONSTANTS.FORM_TYPE_CREATE) {
        XrmCommon.addOnChange(&quot;tmr_assistant&quot;, assistantOnChange);
        XrmCommon.fireOnChange(&quot;tmr_assistant&quot;);
    }
    else{
        throw new Error(&quot;quickCreateStartLoad should only be used on Create forms. Fix that customization!&quot;);
    }
}

function assistantOnChange() {
    // 
    // The relationship mapping defaults tmr_Assistant to the contact this quick create form was launched from.
    // Stop that because it creates a circular reference!
    // The mapping cannot be deleted or modified in the solution so this is a workaround.
    var lookupValue = XrmCommon.getFieldValue(&quot;tmr_assistant&quot;);
    if (lookupValue &amp;&amp; lookupValue.length &gt; 0 &amp;&amp; lookupValue[0]) {
        var selection = lookupValue[0];
        var contextParams = Xrm.Page.context.getQueryStringParameters();
        // if the guids are the same
        if (XrmCommon.compareGuids(selection.id, contextParams._CreateFromId)) {
            XrmCommon.setFieldValue(&quot;tmr_assistant&quot;, null);
            // Now we know we are on a Quick Create form opened by the Assistant lookup
            // so we can set values that make sense for a new Assistant record
            XrmCommon.setFieldValue(&quot;customertypecode&quot;, XrmCommon.CONSTANTS.CONTACT_CUSTOMERTYPECODE_ASSISTANT);
        }
    }
}
</code></pre>
<p>The <code>XrmCommon</code> stuff is just my wrapper around the <code>Xrm.Page</code> object.  In this code block, the function names match Xrm.Page functions, and the only magic they do is check that a field exists on the form before calling the base <code>Xrm.Page</code> function.</p>
<p>Now you can do code specific to creating a new Assistant contact.  We know that if the Assistant lookup GUID matches the <code>_CreateFromId</code>, then this Quick Create form was launched from the Assistant lookup field on a Contact form.  This Quick Create form is going to create a new Assistant Contact!  In our case, the only additional default we wanted was to set the Relationship Type to a custom OptionSet value labeled &quot;Assistant&quot;.  Relationship mappings alone cannot do that.  Since we only wanted one field defaulted, I just added one more line into the Assistant OnChange function that I already had.</p>
<p>If there were many more fields to set, more complicated logic to run, or other records to create or link while creating an Assistant, I would do the work in a plugin registered on the Pre-Operation Create event of Contacts.  If lots of fields were going to get defaulted that the user probably should not change, then good form design would be to not put them on the form at all, and use plugin code to set the defaults during the Pre-Create event.  Do it in the Pre-Create event to create the record with those values already set.  If you do it in the Post-Create event, it will still work, but you cause an Update Contact event which is another transaction and audit history entry.</p>
<p>I think if we did not put the Assistant field on the Quick Create form, we probably would not get the circular reference error in the first place, and we could have used a plugin to default the Relationship Type to Assistant during the Pre-Create stage.</p>

        </article>
        <article class="post">
          <h1 class="post-title">
            <a href="/posts/2015-11-24-aspnet-5-netcore-golive.html">
              ASP.NET 5 RC1 and .NET Core Are &quot;Go Live&quot;
            </a>
          </h1>
          <div class="post-date">
            11/24/2015
          </div>
          <p><a href="%22http://www.hanselman.com/blog/ASPNET5AndNETCoreRC1InContextPlusAllTheConnect2015News.aspx%22">Scott Hanselman has more details.</a> Here is my personal summary of the news.</p>
<p><strong>Visual Studio Code</strong> (like Sublime Text, Github Atom, etc., not an IDE) is Open Source, and in a new Beta that supports Extensions.  Go support, Yeoman, and Open File in Vim (for your command line friends) are some featured extensions.  It is cross platform too!</p>
<p><strong>ASP.NET 5 RC1</strong> is the cross platform release candidate for that Microsoft web framework thing that no one uses outside of Windows.   The &quot;5&quot; part actually means you can develop, host, and run ASP.NET from Linux and OS X.  It has a &quot;Go Live&quot; license which means if you want to deploy it to Production in Linux or OS X, Microsoft will support you.  Documentation is improved compared to the usual MSDN pages too.</p>
<p><a href="%22http://get.asp.net/%22">If you need to start right now</a>, then this site should detect your OS and tell you how to get ASP.NET.  On my phone, it just said view source.</p>
<p>Natively developing and running .NET bits outside of Windows?! Sorcery?!</p>
<p><strong>.NET Core</strong> is the core bits of the .NET Framework, excluding things that tie directly to the Windows OS <em>cough</em> WPF <em>cough</em> WinForms.  Not sure anyone outside Windows wants those anyway.  Development of the Core is primarily driven by ASP.NET 5 workloads, but it aims to fulfill the desire for a modular runtime where features and libraries can be cherry picked.  It is the &quot;If you ask for a banana, you get only a banana and NOT the Gorilla and NOT the rest of the jungle&quot; kind of thing. <a href="%22http://docs.asp.net/en/latest/conceptual-overview/dotnetcore.html%22%3Ehttp://docs.asp.net/en/latest/conceptual-overview/dotnetcore.html%22">Conceptual overview</a> of ASP.NET Core.</p>
<p>The <strong>.NET Execution Environment (DNX)</strong> is where you pick the .NET bits you want available for your runtime environment on your target platform.  It is the SDK for your application.  The DNX Version Manager (DNVM) allows you to wrangle your many DNX versions and flavors, and you can switch between them a la command line.
<a href="%22http://docs.asp.net/en/latest/dnx/overview.html%22%3Ehttp://docs.asp.net/en/latest/dnx/overview.html%22">DNX overview on ASP Net docs.</a></p>
<p>Why would you want to run Microsoft code on Linux?  Maybe that is what your IT staff knows.  Maybe you do not want to have that one Microsoft box in the corner.  The DNX and .NET Core lets you treat Linux as just another place to run your bits.  Well, CentOS and CentOS derivations are not supported yet as of RC1's known issues.</p>
<p>I rip off Scott Hanselman's closing remarks from <a href="%22http://www.hanselman.com/blog/ASPNET5AndNETCoreRC1InContextPlusAllTheConnect2015News.aspx%22">his blog post about all of this</a>.</p>
<blockquote>
<p>WHAT DOES IT ALL MEAN?
It means that you can build basically whatever you want, however you want. You can use the editor you like, the OS you like, and the languages you like. VSCode on a Mac doing Node and deploying to Azure? Check. ASP.NET 5 with C# to <a href="%22http://blogs.technet.com/b/momteam/archive/2015/11/04/oms-agent-for-linux-now-available.aspx%22">Docker Containers in a bunch of VMs created in Azure and managed with Microsoft Operations Manager</a>? Check. And on and on. Node.js on VS, C to Raspberry Pi's in C in VS, whatever you dig. It's a whole new world.</p>
</blockquote>

        </article>
      </div>
    </div>
  </body>
</html>